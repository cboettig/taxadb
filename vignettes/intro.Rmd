---
title: "Quickstart for taxadb"
author: "Carl Boettiger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

```

Here we illustrate the use of `taxadb` to resolve names in the Breeding Bird Survey species list more completely.

```{r message=FALSE}
library(tidyverse)
library(taxadb)
```

```{r message=FALSE}
td_create("all")
```


```{r message=FALSE}
bbs <- read_tsv(system.file("extdata/bbs.tsv", package="taxadb"))
dim(bbs)
```

Outline strategy for name resolution. 

ID resolution including synonym mapping.

```{r}
bbs_ids <- 
bbs %>% 
  select(species) %>%
  mutate(
         gbif = get_ids(species, "gbif"),
          col = get_ids(species, "col" ),
         itis = get_ids(species, "itis"),
         ncbi = get_ids(species, "ncbi"),
           wd = get_ids(species, "wd"  ),
         iucn = get_ids(species, "iucn"),
          ott = get_ids(species, "ott" ) 
  )

```



```{r}
bbs_ids %>% 
  select(-species) %>% 
  purrr::map_dbl(function(x) sum(!is.na(x)))
```

`get_ids` looks only for exact matches.  Certain names may not uniquely resolve to a single ID, such as a name which is a recognized synonym for two separate taxonomic groups (such as may happen if a species is split.) 


We can get more matches by cleaning the names first.  The `clean_names()` function provides several simple string manipulations to tidy names to improve the probability of a match: missing species (specific eptithets) such as `Accipiter sp.` drop the `sp.`, allowing matches against Genus names, and intraspecific epithets such as `Colaptes auratus cafer` are dropped to binomial names, `Colaptes auratus`.  These transformations may not be appropriate for certain use cases, and should be used with care.  

Observe that truncating names would result in a handful of subspecies being resolved only to the species level identifiers:

```{r}
bbs_cleaned_ids <- 
  bbs_ids %>% 
  select(species, ott) %>% 
  mutate(ids_post_clean = 
           get_ids(clean_names(species, binomial_only = TRUE), 
                   "ott", "prefix"))
bbs_cleaned_ids %>% na.omit() %>% filter(ott != ids_post_clean)
x <- bbs_cleaned_ids %>% na.omit() %>% filter(ott != ids_post_clean)  

x
by_id(x$ids_post_clean, provider = "ott")
```

```{r}
bbs_cleaned_ids %>% filter(is.na(ott) & !is.na(ids_post_clean))
```


```{r}
pick <- function(A, B){ A[is.na(A)] <- B[is.na(A)]; A }

ott_ids <- bbs_cleaned_ids %>% mutate(ids = pick(ott, ids_post_clean))
```






```{r}
unmatched <- ott_ids %>% 
  filter(is.na(ids)) %>% 
  select(species, ids) %>%
  mutate(species = clean_names(species))


unmatched
```

Of the remaining 10 names, 3 are clearly common names (`gull`, `tern`, `woodpecker`), two (`trochilid` and `ardeid`) are references to family names, *Trochilidae* and *Ardeidae*, and the remaining five are unresolved.  


We can confirm that the two family names can be resolved:

```{r}
c("Trochilidae",  "Ardeidae") %>% by_name("ott")
```

We can also use the `vernacularName` field available in some naming providers to resolve common names:

```{r}
by_rank("Aves", "class", "col") %>% 
  filter(grepl("Woodpecker", vernacularName)) %>%
  select(vernacularName, scientificName, acceptedNameUsageID)

#by_common(c("Woodpecker"), "col")
```

Let us attempt to resolve the remaining five names.  

Consulting IUCN Redlist names, we can resolve acceptedNameUsageIDs for four of these five:

```{r}
unmatched %>%
  filter(grepl(" ", species)) %>%
  mutate(iucn = get_ids(species, "iucn", "prefix"))
```


By consulting the synonyms table, we can quickly see what other names these species might be known by:

```{r}
syn <- unmatched$species %>% 
  synonyms("iucn") %>% distinct()
syn
```

Note that three of the four synonyms given by IUCN are considered accepted names in OTT:

```{r}
syn %>% 
  rename(IUCN_name = acceptedNameUsage,
         OTT_name = synonym) %>%
  mutate(ott_id =  get_ids(OTT_name, "ott"),
         iucn_id = get_ids(IUCN_name, "iucn"))
```

We cannot simply assume that we can crosswalk synonyms between different providers, as providers may be operating on different taxonomic concepts.  In this example, IUCN recognizes four distinct taxa
while OTT recognizes only thee.

