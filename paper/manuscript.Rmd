---
title: "taxadb: A High-Performance Local Taxonomic Database Interface"
author:
  - name: "Kari Norman"
    affiliation: ucb
  - name: "Jorrit Poelen"
    affiliation: jorritt
  - name: "Scott Chamberlain"
    affiliation: ropensci      
  - name: "Carl Boettiger"
    affiliation: ucb, 1
address:
  - code: ucb
    address: "Dept of Environmental Science, Policy, and Management, University of California Berkeley, Berkeley CA 94720-3114, USA"
  - code: jorrit
    address: "Independent consultant, Oakland, CA, USA"
  - code: ropensci
    address: "The rOpenSci Project, University of California Berkeley, Berkeley CA 94720-3114, USA"
abstract: |
  A familiar and growing challenge in ecological and evolutionary research is that of reconciling scientific names of relevant taxa when combining data from separate sources. While this problem is already well understood and numerous naming authorities have been created to address the issue, most researchers lack a fast, consistent, and intuitive way to reconcile taxonomic names.  Here, we present `taxadb` R package to address this gap.  In contrast to existing tools, `taxadb` provides the following:
  1) `taxadb` accesses established naming authorities to resolve synonyms, IDs, and hiearchical classification.  
  2) `taxadb` creates a local database, managed automatically from within R, that provides fast operations on millions of taxonomic names.
  3) `taxadb` provides a consistent and intuitive data format
  4) `taxadb` is built on a simple, extensible and language agnostic design that can easily accomodiate new authorities.
  
journal: "Methods in Ecology & Evolution"
date: "`r Sys.Date()`"
bibliography: refs.bib
output: rticles::elsevier_article
---



Synonyms vs accepted names. How many species of chameleons are described?

Inconsistencies: errors or disputes? Taxon concepts.


-----

1. A problem already "solved" including ITIS, NCBI, CoL, GBIF, WikiData, FishBase, and The Plant List


2. Performance.  A fundamental challenge of most existing services is the use of internet-based Application Programming Interfaces, (web API)s to resolve individual names.  The motivation for an API-based approach is reasonable: (1) Web APIs are a ubiquitous standard of data exchange (2) make very minimal assumptions about the language, software, or hardware avaialable to the user, (3) users access a single centrally managed database that is maintained and upgraded by the provider, and (4) the provider can easily control access to the data, measure usage statistics, and enforce rate limits.  Many existing tools provide bindings of these APIs as functions to a specific language [@chamberlain2013; @taxize; @itis; @rotl; @worrms; @wikitaxa]

Instead of binding existing web APIs, `taxadb` is built around a set compressed text files following a simple and consistent schema (discussed below). These files are automatically downloaded and imported and stored on a local database by `taxadb`.  By default `taxadb` uses MonetDBLite [@monetdblite], a columnar-oriented relational database requiring no additional installation and providing persistent disk-based storage which can be orders of magnitude faster than traditional database servers such as Postgres [@monetdblite]

3. Consistency 


```{r include=FALSE}
knitr::opts_chunk$set(message=FALSE)
```

The purpose and strengths of `taxadb` can be most easily seen through an introductory example.  

```{r message=FALSE}
library(tidyverse)
library(taxadb)
```

```{r message=FALSE}
td_create("all")
```


```{r message=FALSE}
bbs <- read_tsv(system.file("extdata/bbs.tsv", package="taxadb"))
dim(bbs)
```

Outline strategy for name resolution. 

ID resolution including synonym mapping.

```{r}
bbs_ids <- 
bbs %>% 
  select(species) %>%
  mutate(
         gbif = get_ids(species, "gbif", "prefix"),
          col = get_ids(species, "col",  "prefix"),
         itis = get_ids(species, "itis", "prefix"),
         ncbi = get_ids(species, "ncbi", "prefix"),
     wikidata = get_ids(species, "wd",   "prefix"),
         iucn = get_ids(species, "iucn", "prefix"),
          ott = get_ids(species, "ott",  "prefix") 
  )

```



```{r}
bbs_ids %>% 
  select(-species) %>% 
  purrr::map_dbl(function(x) sum(!is.na(x)))
```

`get_ids` looks only for exact matches.  Certain names may not uniquely resolve to a single ID, such as a name which is a recognized synonym for two separate taxonomic groups (such as may happen if a species is split.) 


We can get more matches by cleaning the names first.  The `clean_names()` function provides several simple string manipulations to tidy names to improve the probability of a match: missing species (specific eptithets) such as `Accipiter sp.` drop the `sp.`, allowing matches against Genus names, and intraspecific epithets such as `Colaptes auratus cafer` are dropped to binomial names, `Colaptes auratus`.  These transformations may not be appropriate for certain use cases, and should be used with care.  

Observe that truncating names would result in a handful of subspecies being resolved only to the species level identifiers

```{r}
bbs_cleaned_ids <- 
  bbs_ids %>% 
  select(species, ott) %>% 
  mutate(ids_post_clean = 
           get_ids(clean_names(species, binomial_only = TRUE), 
                   "ott", "prefix"))
bbs_cleaned_ids %>% na.omit() %>% filter(ott != ids_post_clean)
x <- bbs_cleaned_ids %>% na.omit() %>% filter(ott != ids_post_clean)  

x
descendants(id = x$ids_post_clean, provider = "ott")
```

```{r}
bbs_cleaned_ids %>% filter(is.na(ott) & !is.na(ids_post_clean))
```


```{r}
pick <- function(A, B){ A[is.na(A)] <- B[is.na(A)]; A }

ott_ids <- bbs_cleaned_ids %>% mutate(ids = pick(ott, ids_post_clean))
```






```{r}
unmatched <- ott_ids %>% 
  filter(is.na(ids)) %>% 
  select(species, ids) %>%
  mutate(species = clean_names(species))


unmatched
```

Of the remaining 10 names, 3 are clearly common names (`gull`, `tern`, `woodpecker`), two (`trochilid` and `ardeid`) are references to family names, *Trochilidae* and *Ardeidae*, and the remaining five are unresolved.  Let us attempt to resolve these five before we consider the cases of common names and family names.  

Consulting IUCN Redlist names, we can resolve acceptedNameUsageIDs for four of these five:

```{r}

unmatched %>% mutate(iucn = get_ids(species, "iucn", "prefix"))
```

By consulting the synonyms table, we can see what other names these species might be known by:

```{r}
syn <- unmatched$species %>% synonyms("iucn")
syn
```


Alternately, sticking with the standard `dwc` schema:

```{r}
iucn_ids <- unmatched$species %>% ids("iucn") %>% select(acceptedNameUsageID) %>% distinct()
right_join(taxa_tbl("iucn"), iucn_ids, copy=TRUE, by ="acceptedNameUsageID") %>% 
  select(scientificName, taxonomicStatus, acceptedNameUsageID, taxonRank, taxonID)
```


```{r}
x <- syn %>% 
  mutate(ott_id = get_ids(synonym, "ott", "prefix")) %>% 
  select(input, ott_id) %>%
  na.omit()
x
```

```{r}
syn$synonym %>% get_ids("ott", "prefix")
```

```{r}
descendants(id = x$ott_id, provider = "ott") %>% select(scientificName, taxonomicStatus, acceptedNameUsageID)
```


Note that three of the four synonyms given by IUCN are considered accepted names in OTT:

```{r}
syn$synonym %>% na.omit() %>% ids("ott") %>% select(input, scientificName, acceptedNameUsageID, taxonomicStatus)
```


We can confirm the family names can be resolved:

```{r}
c("Trochilidae",  "Ardeidae") %>% ids("ott")
```

We can use the common names table to resolve common names:



(GBIF lists *Antigone canadensis* as a synonym for *Grus canadensis*; this appears backwards as the Sandhill Crane was moved out of *Grus* after molecular analyses showed it made that taxon polyphyletic; https://en.wikipedia.org/wiki/Sandhill_crane). 


