---
title: "taxadb: A High-Performance Local Taxonomic Database Interface"
author:
  - name: "Kari Norman"
    affiliation: ucb
  - name: "Jorrit Poelen"
    affiliation: jorritt
  - name: "Scott Chamberlain"
    affiliation: ropensci      
  - name: "Carl Boettiger"
    affiliation: ucb, 1
address:
  - code: ucb
    address: "Dept of Environmental Science, Policy, and Management, University of California Berkeley, Berkeley CA 94720-3114, USA"
  - code: jorrit
    address: "Independent consultant, Oakland, CA, USA"
  - code: ropensci
    address: "The rOpenSci Project, University of California Berkeley, Berkeley CA 94720-3114, USA"
abstract: |
  A familiar and growing challenge in ecological and evolutionary research is that of reconciling scientific names of relevant taxa when combining data from separate sources. While this problem is already well understood and numerous naming authorities have been created to address the issue, most researchers lack a fast, consistent, and intuitive way to reconcile taxonomic names.  Here, we present `taxadb` R package to address this gap.  In contrast to existing tools, `taxadb` provides the following:
  1) `taxadb` accesses established naming authorities to resolve synonyms, IDs, and hiearchical classification.  
  2) `taxadb` creates a local database, managed automatically from within R, that provides fast operations on millions of taxonomic names.
  3) `taxadb` provides a consistent and intuitive data format
  4) `taxadb` is built on a simple, extensible and language agnostic design that can easily accomodiate new authorities.
  
journal: "Methods in Ecology & Evolution"
date: "`r Sys.Date()`"
bibliography: refs.bib
output: rticles::elsevier_article
---

```{r message=FALSE, include = FALSE}
library(tidyverse)
```



As ecologists and evolutionary biologists synthesize datasets across larger and larger assemblies of species, we face a continual challenge of reconciling taxonomic names. How many species are in the combined data? Do the studies use the same names for the same species, or do they use different synonyms for the same species? Failing to correct for such differences can lead to significant inflation of species counts and miss-aligned  datasets (Figure 1).  These challenges have become particularly acute as it becomes increasingly common for researchers to work across larger number and diversity of species in any given analysis, which may preclude the resources or substantative taxonomic expertise all clades needed to resolve scientific names.
While these issues have long been recognized in the literature [], and a growing number of databases and tools have emerged and grown over the past few decades [e.g. @itis; @ncbi; @col], it remains difficult to resolve taxonomic names to a common authority in a transparent, efficient, and automatable manner. Here, we present an R package, `taxadb`, which seeks to address this gap.

Databases of taxonomic names such as the Integrated Taxonomic Information System [ITIS; @itis], the National Center for Biological Information's (NCBI) Taxonomy database, [@ncbi], the Catalogue of Life [COL; @col], and over one hundred other providers have sought to address these problems by providing expert-curated lists of accepted taxonomic names, synonyms, associated taxonomic rank, hierarchical classification, and scientific authority (e.g. author and date) establishing a scientific name.
The R language [@R] is widely used in ecology and evolution [@Lai2019] and the `taxize` package [@Chamberlain2012] has become a popular way R users to interact with naming providers and name resolution services.  `taxize` implements bindings to the web APIs (Application Programming Interface) hosted by many popular taxonomic name providers. Unfortunately, this means that functions in the `taxize` are impacted by several major drawbacks that are inherent in the implementation of these central API servers, such as:

- Queries require internet access at all times
- Queries are slow and inefficient to implement and perform; frequently requiring separate API calls for each taxonomic name
- The type of query is highly limited by the API design. For instance, it is impossible usually impossible to make queries across the entire corpus of names, such as "which accepted name has the most known synonyms?"
- Both query formats and responses differ substantially across different naming providers, making it difficult to apply a script designed for one provider to different provider.
- Most queries are not reproducible, as the results depend on the state of the central server (and potentially the quality of the internet connection).  Many names providers update the server data either continuously or at regular intervals, including both revising existing names and adding new names.  <!-- For instance, @predicts2014 observes that 2013 Catalogue of Life includes the genus "Notiophilus" in two separate families, contrary to the rules of nomenclature.  This error does not occur in the 2018 edition. -->

Instead of binding existing web APIs, `taxadb` is built around a set compressed text files following a consistent, standardized layout or schema (discussed below). These files are automatically downloaded and imported and stored on a local database by `taxadb`.  The largest of the taxonomic naming providers today contain under 6 million name records with uncompressed file sizes under a GB, and can be compressed to around 50 MB and downloaded in under a minute on a 1 MB/s connection.  In contrast, querying a single name over the web API, requiring the server to respond, execute the query, and serialize the response, can take several seconds. Thus it does not take many taxa before transferring the entire data set to query locally is more efficient.  Moreover, this local copy can be cached on the user's machine, requiring only the one-time setup and enabling offline use.

After installing the `taxadb` R package, users can create local copies of data from any of the providers using the `td_create()` function and specifying the provider abbreviation (see Table 1), or `all` to install all available providers:

```{r}
library(taxadb)
td_create("all")
```

<!--  Next 2 paragraphs should possibly be left to a manual, but are likely to be overlooked aspects there... -->
This one-time download will download and import local copies of the provider data. By default `taxadb` creates a MonetDBLite database instance [@monetdblite], a columnar-oriented relational database requiring no additional installation while also providing persistent disk-based storage, and data is stored in the appropriate location specified for applications by the operating sytstem [@rappdirs]. Users can customize this location, or opt for any alternative relational database backend by providing alternative arguments, though the default MonetDBLite system can be an order of magnitude faster than popular alternatives such as Postgres [@monetdblite].  `taxadb` will automatically handle opening, caching, and closing the MonetDBLite connection, but note that one limitation of MonetDBLite is the restriction against concurrent access: two separate R sessions on the same machine cannot both access the database at the same time. Users who need concurrent access from multiple sessions may wish to use a standalone MonetDB server or other database server instead.

All `taxadb` functions can also operate in one-time-use mode without first installing a standalone server.  If a function requests a provider which has not been installed, the relevant table can be downloaded and read directly into memory.  This requires sufficient memory be available to hold the entire table (typically 1-2 GB) and will only be cached for the R session.  This can be useful in special cases such as execution on remote servers where this will be faster than importing the data locally, or to allow other packages to use methods such as `get_ids()` internally without assuming users will have first created a local copy with `td_create()`. Specify `db=NULL` on any `taxadb` function to force this in-memory dispatch. 

Functions in `taxadb` are organized into several families: 

- database functions  `td_create()`, `td_connect()` and `taxa_tbl()`
- queries that return vectors: `get_ids()` and it's complement, `get_names()`,
- queries that filter the underlying taxonomic data frames: `by_name()`, `by_rank()`, `by_id()`, and `by_common()`,
- and helper utilities, such as `clean_names()`. 


## Returning IDs

Resolving names to IDs 

```{r}
birds <- data.frame(species = c(
"Leucocarbo colensoi",
"Saxicola macrorhynchus",
"Peneothello sigillata",
"Ichthyaetus melanocephalus",
"Phalacrocorax colensoi",
"Saxicola macrorhyncha",
"Peneothello sigillatus",
"Poospiza lateralis lateralis",
"Larus melanocephalus",
"Myadestes elizabeth"
), stringsAsFactors = FALSE)
```


Resolving names to identifiers (using the default provider, ITIS) reveals that we have only 5 unique ids, as many of our names were known synonyms:

```{r}
birds %>% mutate(id = get_ids(species)) %>% arrange(id)
```
This step has also revealed one name that could not be resolved.  This could be a synonym not known to ITIS, or a species not known to ITIS, but often indicates a misspelling. A peek at other members of this genus starting with `"e"` might help us spot the issue:

```{r}
by_rank("Myadestes", "genus") %>% filter(grepl("^e", specificEpithet))
```
 
 
 
 
```{r}
ids <- birds$species %>% get_ids() %>% unique() 
data.frame(ids, species = get_names(ids))
```

```{r}
birds %>%
  mutate(id = get_ids(species), 
         accepted = get_names(id)) %>%
  select(id, accepted) %>%
  distinct()
   
```




## Filtering operations


```{r}
by_name()
```


```{r}
by_rank()
```


```{r}
by_id()
```


## Database operations

The `taxa_tbl()` function is the low-level interface at the heart of most `taxadb` functions, returning a connection to a single table in the database.  

## Subsetting the database

Working directly with `taxa_tbl()` requires some familarity with `dplyr` and the way in which it operates when using remote connections.  For many users this would create a significant hurdle: for instance, while typical operations like `select()`, `group_by()`, `summarise()` and `filter()` work in the same way on remote connections and in-memory data, operations that rely on specific R functions that `dplyr` cannot translate to SQL, such as 

"Which bird families starting with the letter 'B'?"

```r
taxa_tbl("itis") %>% filter(class=="Aves", grepl("B.*", family)) %>% count(family)
```

will result in an error, becuase `grepl` is an R-specific function.  Using the `by_*` functions, which `collect()` results into memory by default, will avoid this:


```{r}
by_rank("Aves", "class") %>% 
  filter(grepl("B.*", family)) %>% 
  count(family, sort = TRUE)
```




<!--
The motivation for an API-based approach is reasonable: (1) Web APIs are a ubiquitous standard of data exchange (2) make very minimal assumptions about the language, software, or hardware avaialable to the user, (3) users access a single centrally managed database that is maintained and upgraded by the provider, and (4) the provider can easily control access to the data, measure usage statistics, and enforce rate limits.  Many existing tools provide bindings of these APIs as functions to a specific language, including `taxize`, `tits`, `rotl`, `worms`, `redlist` and `wikitaxa` [@Chamberlain2013; @itis; @rotl; @worrms; @wikitaxa]
-->




Darwin Core schema.

### Supported providers



<!--
comment that taxonomic backbones aren't really the same thing:
In addition to these projects, large biodiversity informatics efforts such as the Global Biodiversity Information Facility [GBIF; @gbif], publish the 'taxonomic backbone' -->


- Resolve names to identifiers
- Resolve synonyms to accepted names
- Associate names with taxonomic rank and heirarchical classification

discuss use Scientific names vs identifiers.  taxonConcepts?


several major ongoing efforts seek to address this problem, including:

- the Integrated Taxonomic Information System [ITIS; @itis], original formed to standardize taxonomic name usage across many agencies in the United States federal government, 
- the National Center for Biological Information's (NCBI) Taxonomy database, [@ncbi]
- Catalogue of Life annual Species list




- `taxadb` is not intended as an improvement or replacement for any existing approaches to taxonomic name resolution. Instead, it fills an important gap between existing tools and typical research patterns.  

In particular, `taxadb` is not a replacement for the APIs or databases provided, but merely an interface to taxonomic naming information contained within that data. 

- `taxadb` works from versioned snapshots of the data providers. 

- All `taxadb` functions are specific to a provider, while operating consistently across different providers.  
- `taxadb` does not attempt to present any unified taxonomic backbone or synthesis from existing naming providers, or make any assertions, numerical scores or other inferences about the data or matches to the data -- it is merely a tool for accessing this infromation.  This contrasts from other approaches such as the Global Names Resolver, which 

Many taxonomic name providers are explicitly based on other existing naming assembeges.  


There is an important objection to this approach that must also be addressed.  

@Franz2018 

>  no self-respecting biodiversity researcher would or should trust aggregated data blindly, that indeed careful data cleaning is almost always necessary and expected to render the downloaded data fit for purpose, and that therefore aggregator services need to be understood mainly or merely as data discovery tools.

> We reject this deflationary view for four reasons. For one, aggregators frequently blur the lines between advertizing their services just as a data discovery tool or as a more powerful data signal tool. Second, the biases inherent in using unitary backbones remain in place even if users are only interested in discovering all relevant data for their research purpose. If the backbone-based data record modulations are not easily retrievable through primary on-line interfaces, then users are significantly constrained in their ability to design search queries with high rates of precision and recall (81). Third, let us assume that labor-intensive off-line data quality review and correction efforts are indeed the norm, prior to publishing. Then why must the fruits of these efforts remain outside of the aggregator’s environment? Why can they not immediately flow back into the same aggregation domain, while recording the provenance of expert changes? In other words, if the workflow of rendering data fit for purpose flows only in one direction, i.e. from the on-line aggregate to the off-line quality review and publication, then our criticism of the design stands.

The inability to make automate use and manipulation 

(Figure 1: schematic example of data join?)


Assemble data across multiple studies 

How many species of Chameleons are known? There are over 


```{r}
taxa_tbl("col") %>% count(taxonomicStatus, sort = TRUE)
```

```{r}
taxa_tbl("col") %>% count(acceptedNameUsageID, sort=TRUE) %>% head()
```

```{r}
taxa_tbl("iucn") %>% count()

taxa_tbl("itis") %>%
  filter(taxonomicStatus == "accepted") %>%
  count()
```

131,042 of the 580,304 of *accepted names* in ITIS are not recognized by the Catalogue of Life as either accepted names or known synonyms. 27,507 names in the IUCN Redlist are not in the 2018 Catalogue of Life.

```{r}
taxa_tbl("iucn") %>%
  select(scientificName) %>% 
  left_join(taxa_tbl("col")) %>% 
  filter(is.na(acceptedNameUsageID)) %>% 
  count()

```



```{r}
most_synonyms <- taxa_tbl("col") %>% count(acceptedNameUsageID, sort=TRUE) %>% head() %>% collect()
by_id(most_synonyms$acceptedNameUsageID, "col")
most_synonyms %>% mutate(accepted = get_names(acceptedNameUsageID, "col"))

synonyms("Mentha longifolia subsp. longifolia", "col")
```


1. A problem already "solved" including ITIS, NCBI, CoL, GBIF, WikiData, FishBase, and The Plant List


3. Consistency 


```{r include=FALSE}
knitr::opts_chunk$set(message=FALSE)
```

The purpose and strengths of `taxadb` can be most easily seen through an introductory example.  

```{r message=FALSE}
library(tidyverse)
library(taxadb)
```

```{r message=FALSE}
td_create("all")
```


```{r message=FALSE}
bbs <- read_tsv(system.file("extdata/bbs.tsv", package="taxadb"))
dim(bbs)
```

Outline strategy for name resolution. 

ID resolution including synonym mapping.

```{r}
bbs_ids <- 
bbs %>% 
  select(species) %>%
  mutate(
         gbif = get_ids(species, "gbif"),
          col = get_ids(species, "col" ),
         itis = get_ids(species, "itis"),
         ncbi = get_ids(species, "ncbi"),
           wd = get_ids(species, "wd"  ),
         iucn = get_ids(species, "iucn"),
          ott = get_ids(species, "ott" ) 
  )

```



```{r}
bbs_ids %>% 
  select(-species) %>% 
  purrr::map_dbl(function(x) sum(!is.na(x)))
```

`get_ids` looks only for exact matches.  Certain names may not uniquely resolve to a single ID, such as a name which is a recognized synonym for two separate taxonomic groups (such as may happen if a species is split.) 


We can get more matches by cleaning the names first.  The `clean_names()` function provides several simple string manipulations to tidy names to improve the probability of a match: missing species (specific eptithets) such as `Accipiter sp.` drop the `sp.`, allowing matches against Genus names, and intraspecific epithets such as `Colaptes auratus cafer` are dropped to binomial names, `Colaptes auratus`.  These transformations may not be appropriate for certain use cases, and should be used with care.  

Observe that truncating names would result in a handful of subspecies being resolved only to the species level identifiers

```{r}
bbs_cleaned_ids <- 
  bbs_ids %>% 
  select(species, ott) %>% 
  mutate(ids_post_clean = 
           get_ids(clean_names(species, binomial_only = TRUE), 
                   "ott", "prefix"))
bbs_cleaned_ids %>% na.omit() %>% filter(ott != ids_post_clean)
x <- bbs_cleaned_ids %>% na.omit() %>% filter(ott != ids_post_clean)  

x
by_id(x$ids_post_clean, provider = "ott")
```

```{r}
bbs_cleaned_ids %>% filter(is.na(ott) & !is.na(ids_post_clean))
```


```{r}
pick <- function(A, B){ A[is.na(A)] <- B[is.na(A)]; A }

ott_ids <- bbs_cleaned_ids %>% mutate(ids = pick(ott, ids_post_clean))
```






```{r}
unmatched <- ott_ids %>% 
  filter(is.na(ids)) %>% 
  select(species, ids) %>%
  mutate(species = clean_names(species))


unmatched
```

Of the remaining 10 names, 3 are clearly common names (`gull`, `tern`, `woodpecker`), two (`trochilid` and `ardeid`) are references to family names, *Trochilidae* and *Ardeidae*, and the remaining five are unresolved.  Let us attempt to resolve these five before we consider the cases of common names and family names.  

Consulting IUCN Redlist names, we can resolve acceptedNameUsageIDs for four of these five:

```{r}

unmatched %>% mutate(iucn = get_ids(species, "iucn", "prefix"))
```

By consulting the synonyms table, we can see what other names these species might be known by:

```{r}
syn <- unmatched$species %>% synonyms("iucn")
syn
```


Alternately, sticking with the standard `dwc` schema:

```{r}
iucn_ids <- unmatched$species %>% by_name("iucn") %>% select(acceptedNameUsageID) %>% distinct()
right_join(taxa_tbl("iucn"), iucn_ids, copy=TRUE, by ="acceptedNameUsageID") %>% 
  select(scientificName, taxonomicStatus, acceptedNameUsageID, taxonRank, taxonID)
```


```{r}
syn$synonym %>% get_ids("ott", "prefix")
```

Note that three of the four synonyms given by IUCN are considered accepted names in OTT:

```{r}
syn$synonym %>% na.omit() %>% by_name("ott") %>% select(input, scientificName, acceptedNameUsageID, taxonomicStatus)
```


We can confirm the family names can be resolved:

```{r}
c("Trochilidae",  "Ardeidae") %>% by_name("ott")
```

We can use the common names table to resolve common names:



(GBIF lists *Antigone canadensis* as a synonym for *Grus canadensis*; this appears backwards as the Sandhill Crane was moved out of *Grus* after molecular analyses showed it made that taxon polyphyletic; https://en.wikipedia.org/wiki/Sandhill_crane). 


